{"componentChunkName":"component---src-templates-blog-post-js","path":"/docker/장고프로젝트 docker로 배포하기 with elasticsearch/","result":{"data":{"site":{"siteMetadata":{"title":"Woo's Dev Log","author":"nickhealthy","siteUrl":"https://nickhealthy.github.io","comment":{"disqusShortName":"","utterances":"nickhealthy/nickhealthy.github.io"},"sponsor":{"buyMeACoffeeId":""}}},"markdownRemark":{"id":"2948cd5d-c3e6-568a-b6db-e454aee6d308","excerpt":"멀티캠퍼스 클라우드 교육과정을 들으면서 도커, 쿠버네티스, 클라우드 등 전반적으로 많은 것을 배웠다.\n그 중 1차 프로젝트는 장고 웹 프로젝트였는데 이때는 파이썬, 웹 스크래핑, 데이터 조작을 위한 pandas, 장고, SQL/NoSQL 정도만 배웠다.\n그리고 이후에 2차 3차 프로젝트를 수행했을 때 AWS…","html":"<p>멀티캠퍼스 클라우드 교육과정을 들으면서 도커, 쿠버네티스, 클라우드 등 전반적으로 많은 것을 배웠다.\n그 중 1차 프로젝트는 장고 웹 프로젝트였는데 이때는 파이썬, 웹 스크래핑, 데이터 조작을 위한 pandas, 장고, SQL/NoSQL 정도만 배웠다.\n그리고 이후에 2차 3차 프로젝트를 수행했을 때 AWS 서비스를 이용하면서 클라우드쪽은 건드려 본것 같은데 가상화 컨테이너의 기술로서는 프로젝트를 진행해보지 않은 것 같아 수료 이후 도커를 공부할 겸 배포해보기로 했다.</p>\n<blockquote>\n<p>해결하는데 생각보다 정말 오래걸렸다… DB와 장고 서버 <code class=\"language-text\">Dockerfile</code> 작성 및 <code class=\"language-text\">docker-compose</code> 연동은 비교적 쉽게 되었지만 <code class=\"language-text\">elasticsearch</code> 컨테이너와의 연동이 안되었던 것..</p>\n<p>결과적으로 해결되었고 에러를 해결하느라 돌고 돌아 리눅스, 도커 네트워크, 엘라스틱 서치 등등 많은 것을 공부해서 손해는 아니라고 생각한다.</p>\n</blockquote>\n<h2 id=\"방법1-dockerfile-정의\" style=\"position:relative;\"><a href=\"#%EB%B0%A9%EB%B2%951-dockerfile-%EC%A0%95%EC%9D%98\" aria-label=\"방법1 dockerfile 정의 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>방법1. Dockerfile 정의</h2>\n<p>처음에는 도커 파일을 개별적으로 정의해 <strong>각각의 컨테이너들을 연결해보았다.</strong></p>\n<blockquote>\n<p>여기서부터 DB, 장고는 연동이 완료 되었고, 장고 서버도 정상적으로 돌아갔지만 엘라스틱서치는 안되는 상태였음</p>\n</blockquote>\n<ul>\n<li>엘라스틱 서버 실행 확인 명령어</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">curl</span> http://localhost:9200/_cluster/health?pretty</code></pre></div>\n<ol>\n<li>mariaDB 서버 실행</li>\n</ol>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">$ docker run --rm --name db -e <span class=\"token assign-left variable\">MYSQL_ROOT_PASSWORD</span><span class=\"token operator\">=</span>project -e <span class=\"token assign-left variable\">MYSQL_DATABASE</span><span class=\"token operator\">=</span>project_db -e <span class=\"token assign-left variable\">MYSQL_USER</span><span class=\"token operator\">=</span>project -e <span class=\"token assign-left variable\">MYSQL_PASSWORD</span><span class=\"token operator\">=</span>project mariadb</code></pre></div>\n<blockquote>\n<p>mariaDB는 딱히 도커 파일을 안만들어줘도 될거같아서 공식 이미지를 다운받는 동시에 서버를 실행시켰다.</p>\n</blockquote>\n<ol start=\"2\">\n<li>backend <code class=\"language-text\">Dockerfile</code> 정의</li>\n</ol>\n<div class=\"gatsby-highlight\" data-language=\"dockerfile\"><pre class=\"language-dockerfile\"><code class=\"language-dockerfile\"><span class=\"token keyword\">FROM</span> python<span class=\"token punctuation\">:</span>3.8.5\n\n<span class=\"token keyword\">RUN</span> apt<span class=\"token punctuation\">-</span>get <span class=\"token punctuation\">-</span>y update\n<span class=\"token keyword\">RUN</span> pip install <span class=\"token punctuation\">-</span><span class=\"token punctuation\">-</span>upgrade pip\n<span class=\"token comment\"># 프로젝트 특성상 필요한 비디오 인코딩 파일 설치</span>\n<span class=\"token keyword\">RUN</span> apt<span class=\"token punctuation\">-</span>get install <span class=\"token punctuation\">-</span>y ffmpeg\n\n<span class=\"token keyword\">WORKDIR</span> /usr/src/app\n<span class=\"token keyword\">COPY</span> requirements.txt /usr/src/app\n<span class=\"token comment\"># 프로젝트에 필요한 패키지를 가상환경으로 한번에 설치 및 관리</span>\n<span class=\"token keyword\">RUN</span> pip install <span class=\"token punctuation\">-</span>r requirements.txt\n<span class=\"token keyword\">COPY</span> . /usr/src/app</code></pre></div>\n<ol start=\"3\">\n<li>backend <code class=\"language-text\">Dockerfile</code> 이미지를 빌드</li>\n</ol>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">$ docker build -t backend <span class=\"token builtin class-name\">.</span></code></pre></div>\n<ol start=\"4\">\n<li>mariaDB와 backend 연동 및 실행</li>\n</ol>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">$ docker run -it -d --rm --name backend -p <span class=\"token number\">8000</span>:8000 --link db -e <span class=\"token assign-left variable\">DJANGO_DB_HOST</span><span class=\"token operator\">=</span>db -e <span class=\"token assign-left variable\">DJANGO_DEBUG</span><span class=\"token operator\">=</span>True backend</code></pre></div>\n<blockquote>\n<p>—link: 연결할 컨테이너 이름</p>\n</blockquote>\n<ol start=\"5\">\n<li>컨테이너 실행 여부 확인</li>\n</ol>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">$ docker <span class=\"token function\">ps</span> -a</code></pre></div>\n<ol start=\"6\">\n<li>backend 컨테이너 내 진입</li>\n</ol>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">$ docker <span class=\"token builtin class-name\">exec</span> -it backend <span class=\"token function\">bash</span></code></pre></div>\n<ol start=\"7\">\n<li>django 서버를 실행하기 전 필요한 설정 명령어 &#x26; django 서버 실행</li>\n</ol>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">$ python manage.py makemigrations\n$ python manage.py migrate\n$ python manage.py runserver <span class=\"token number\">0</span>:8000</code></pre></div>\n<ol start=\"8\">\n<li>\n<p>localhost에서 접속되는 것을 확인</p>\n<ul>\n<li>웹 브라우저에서 <code class=\"language-text\">localhost:8000</code> 입력 후 접속</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"docker-compose로-변경\" style=\"position:relative;\"><a href=\"#docker-compose%EB%A1%9C-%EB%B3%80%EA%B2%BD\" aria-label=\"docker compose로 변경 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>docker-compose로 변경</h2>\n<p>이렇게까지 해서 각각의 도커 컨테이너들끼리 디비와 장고가 연동되었고 서비스를 실행할 수 있었다.(검색엔진인 엘라스틱서치 서버를 제외하고)</p>\n<p>하지만 컨테이너 내에 진입해서 설정을 해주는 것도 많고 복잡하다. 이제 이것을 docker-compose를 이용해 좀 더 수월하게 여러 컨테이너들을 한꺼번에 빌드하고 서버까지 바로 실행되도록 해보았다.</p>\n<p>backend <code class=\"language-text\">Dockerfile</code> 수정</p>\n<div class=\"gatsby-highlight\" data-language=\"dockerfile\"><pre class=\"language-dockerfile\"><code class=\"language-dockerfile\"><span class=\"token keyword\">FROM</span> python<span class=\"token punctuation\">:</span>3.8.5\n\n<span class=\"token keyword\">RUN</span> apt<span class=\"token punctuation\">-</span>get <span class=\"token punctuation\">-</span>y update\n<span class=\"token keyword\">RUN</span> pip install <span class=\"token punctuation\">-</span><span class=\"token punctuation\">-</span>upgrade pip\n<span class=\"token comment\"># 프로젝트 특성상 필요한 비디오 인코딩 파일 설치</span>\n<span class=\"token keyword\">RUN</span> apt<span class=\"token punctuation\">-</span>get install <span class=\"token punctuation\">-</span>y ffmpeg\n\n<span class=\"token keyword\">WORKDIR</span> /usr/src/app\n<span class=\"token keyword\">COPY</span> requirements.txt /usr/src/app\n<span class=\"token comment\"># 프로젝트에 필요한 패키지를 가상환경으로 한번에 설치 및 관리</span>\n<span class=\"token keyword\">RUN</span> pip install <span class=\"token punctuation\">-</span>r requirements.txt\n<span class=\"token keyword\">COPY</span> . /usr/src/app\n\n<span class=\"token keyword\">RUN</span> python manage.py migrate <span class=\"token comment\"># 명령어 추가</span></code></pre></div>\n<blockquote>\n<p>아주 살짝 수정하였지만 docker-compose.yml에서 <code class=\"language-text\">depends_on</code> 을 설정해 주었으므로 장고 컨테이너가 실행된 후 컨테이너 내부 진입으로 migrate 해줄 필요없이 자동적으로 실행이 되도록하였다.</p>\n<p>또한 docker-compose.yml에서 runserver 까지 선언했기 때문에 <strong>docker-compose up 명령으로 위에서와는 다르게 한번에 정상적으로 서버가 실행된다.</strong></p>\n</blockquote>\n<p><code class=\"language-text\">docker-compose.yml</code></p>\n<div class=\"gatsby-highlight\" data-language=\"dockerfile\"><pre class=\"language-dockerfile\"><code class=\"language-dockerfile\">version<span class=\"token punctuation\">:</span> <span class=\"token string\">'3'</span>\nservices<span class=\"token punctuation\">:</span>\n  <span class=\"token comment\"># DB 컨테이너 이름 정의</span>\n  database<span class=\"token punctuation\">:</span>\n    <span class=\"token comment\"># db 서비스에서 사용할 도커 이미지</span>\n    image<span class=\"token punctuation\">:</span> <span class=\"token string\">'mariadb'</span>\n    environment<span class=\"token punctuation\">:</span>\n      <span class=\"token punctuation\">-</span> MYSQL_ROOT_PASSWORD=project\n      <span class=\"token punctuation\">-</span> MYSQL_DATABASE=project_db\n      <span class=\"token punctuation\">-</span> MYSQL_USER=project\n      <span class=\"token punctuation\">-</span> MYSQL_PASSWORD=project\n\n<span class=\"token comment\"># 엘라스틱 서치 컨테이너 연동이 안되는 문제로 DB와 django만 실행할 수 있도록 주석 처리해놓았다.</span>\n  <span class=\"token comment\"># elasticsearch:</span>\n  <span class=\"token comment\">#   image: docker.elastic.co/elasticsearch/elasticsearch:7.10.2</span>\n  <span class=\"token comment\">#   ports:</span>\n  <span class=\"token comment\">#     - '9200:9200'</span>\n  <span class=\"token comment\">#     - '9300:9300'</span>\n  <span class=\"token comment\">#   expose:</span>\n  <span class=\"token comment\">#     - '8000'</span>\n  <span class=\"token comment\">#   environment:</span>\n  <span class=\"token comment\">#     - 'ES_JAVA_OPTS=-Xms512m -Xmx512m'</span>\n  <span class=\"token comment\">#     - discovery.type=single-node</span>\n\n  <span class=\"token comment\"># 앱 컨테이너 이름 정의</span>\n  backend<span class=\"token punctuation\">:</span>\n  \t<span class=\"token comment\"># 데이터베이스 서비스가 실행된 후 장고 서버를 실행하도록 설정</span>\n    depends_on<span class=\"token punctuation\">:</span>\n      <span class=\"token punctuation\">-</span> database\n      <span class=\"token punctuation\">-</span> elasticsearch\n    <span class=\"token comment\"># Dockerfile이 있는 위치</span>\n    build<span class=\"token punctuation\">:</span> .\n    ports<span class=\"token punctuation\">:</span>\n      <span class=\"token punctuation\">-</span> <span class=\"token string\">'8000:8000'</span>\n    environment<span class=\"token punctuation\">:</span>\n      <span class=\"token punctuation\">-</span> DJANGO_DB_HOST=database\n      <span class=\"token punctuation\">-</span> DJANGO_DEBUG=True\n    command<span class=\"token punctuation\">:</span> python manage.py runserver 0<span class=\"token punctuation\">:</span>8000</code></pre></div>\n<ol>\n<li><code class=\"language-text\">docker-compose build</code> 명령어로 빌드를 진행</li>\n<li><code class=\"language-text\">docker-compose up</code> 명령어로 실행</li>\n</ol>\n<p>정상적으로 서버가 실행된다. 또한 위의 도커 파일에서는 <code class=\"language-text\">--link</code> 라는 옵션을 줘서 각 컨테이너를 연결시켜주었는데 해당 <code class=\"language-text\">docker-compose.yml</code> 을 보면 옵션이 빠져있다.</p>\n<p><strong>그 이유는 docker-compose에서는 별도의 네트워크 옵션을 설정해주지 않으면 기본적으로 동일한 네트워크에 서로 연결되어 있기 때문이다.</strong></p>\n<h2 id=\"방법2-엘라스틱서치까지-추가\" style=\"position:relative;\"><a href=\"#%EB%B0%A9%EB%B2%952-%EC%97%98%EB%9D%BC%EC%8A%A4%ED%8B%B1%EC%84%9C%EC%B9%98%EA%B9%8C%EC%A7%80-%EC%B6%94%EA%B0%80\" aria-label=\"방법2 엘라스틱서치까지 추가 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>방법2. 엘라스틱서치까지 추가</h2>\n<p>우선 무작정 찍듯이 하지말고, 원인을 파악하자고 생각했다. 안되는 이유를 알기 위해서 고심해보다가 기존에 호스트 PC에서는 정상적으로 서비스 실행이 된다는 것을 생각하고 <strong>로컬 호스트에서 엘라스틱 서버가 어떻게 작동하는지 먼저 파악</strong>하기로 했다. <strong>즉, 로컬 환경에서 작동방식을 보고 테스트했다는 얘기</strong></p>\n<p>우선 우리 프로젝트는 엘라스틱 서치 서버와 장고서버가 같이 움직인다는 점에서 연관된 기능들은 하나의 컨테이너에 담자는 생각을 했다. (항상 엘라스틱 서치를 먼저 실행하고 장고 서버를 실행한다는 점에서) 그리고 엘라스틱 서치 공식이미지를 사용하였을 때 장고 프로젝트에 필요한 모듈과 패키지들은 아래의 내용과 같다. 또한 <code class=\"language-text\">RUN</code> 명령어를 사용할 경우 도커 이미지에서는 특정 레이어를 생성한다고 한다. 이 레이어는 한번 정의하고 빌드했을 때 그 상태를 고정/유지하며, 여러 개의 RUN 명령어를 남발할 경우 레이어가 여러개가 된다는 사실이다. 그래서 최대한 효율적으로 빌드하기 위해 하나의 <code class=\"language-text\">RUN</code> 명령어 안에서 빌드해 주었다.</p>\n<p>[Dockerfile] 수정</p>\n<div class=\"gatsby-highlight\" data-language=\"dockerfile\"><pre class=\"language-dockerfile\"><code class=\"language-dockerfile\"><span class=\"token keyword\">FROM</span> elasticsearch<span class=\"token punctuation\">:</span>7.10.1\n\n<span class=\"token keyword\">WORKDIR</span> /usr/src/app\n<span class=\"token keyword\">COPY</span> requirements.txt /usr/src/app\n\n<span class=\"token keyword\">RUN</span> yum install <span class=\"token punctuation\">-</span>y gcc openssl<span class=\"token punctuation\">-</span>devel bzip2<span class=\"token punctuation\">-</span>devel libffi<span class=\"token punctuation\">-</span>devel wget make &amp;&amp; \\\n    wget https<span class=\"token punctuation\">:</span>//www.python.org/ftp/python/3.8.5/Python<span class=\"token punctuation\">-</span>3.8.5.tgz &amp;&amp; \\\n    tar xzf Python<span class=\"token punctuation\">-</span>3.8.5.tgz &amp;&amp; \\\n    Python<span class=\"token punctuation\">-</span>3.8.5/configure <span class=\"token punctuation\">-</span><span class=\"token punctuation\">-</span>enable<span class=\"token punctuation\">-</span>optimizations &amp;&amp; \\\n    make altinstall Python<span class=\"token punctuation\">-</span>3.8.5 &amp;&amp; \\\n    ln <span class=\"token punctuation\">-</span>s /usr/local/bin/python3.8 /bin/python3.8 &amp;&amp; \\\n    yum install <span class=\"token punctuation\">-</span>y python3<span class=\"token punctuation\">-</span>devel mysql<span class=\"token punctuation\">-</span>devel &amp;&amp; \\\n    pip3.8 install <span class=\"token punctuation\">-</span><span class=\"token punctuation\">-</span>upgrade pip &amp;&amp; \\\n    pip3.8 install <span class=\"token punctuation\">-</span>r requirements.txt &amp;&amp; \\\n    wget https<span class=\"token punctuation\">:</span>//raw.githubusercontent.com/q3aql/ffmpeg<span class=\"token punctuation\">-</span>install/master/ffmpeg<span class=\"token punctuation\">-</span>install &amp;&amp; \\\n    chmod a+x ffmpeg<span class=\"token punctuation\">-</span>install &amp;&amp; \\\n    ./ffmpeg<span class=\"token punctuation\">-</span>install <span class=\"token punctuation\">-</span><span class=\"token punctuation\">-</span>install release\n\n<span class=\"token keyword\">COPY</span> . /usr/src/app\n<span class=\"token keyword\">CMD</span> <span class=\"token punctuation\">[</span><span class=\"token string\">\"python3.8\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"manage.py\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"runserver\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"0:8000\"</span><span class=\"token punctuation\">]</span></code></pre></div>\n<p>또한 여러 개의 특정 작업 처리를 위해 RUN 명령어 대신 하나의 쉘 스크립를 만들어 모두 처리하도록 하였다. sleep 시간은 각각의 명령어 처리를 위해 기다릴 수 있도록 하기 위함이다.</p>\n<p>또한 <code class=\"language-text\">/usr/local/bin/docker-entrypoint.sh &amp;</code> 이 명령어는 엘라스틱 서치를 데몬(daemon)으로 돌리기 위함이며 포그라운드로 도는 서버는 장고 서버이다.</p>\n<p>[server_start.sh] 생성</p>\n<div class=\"gatsby-highlight\" data-language=\"shell\"><pre class=\"language-shell\"><code class=\"language-shell\"><span class=\"token shebang important\">#!/bin/bash -x</span>\n\n<span class=\"token function\">sleep</span> <span class=\"token number\">15</span>\n\npython3.8 manage.py migrate\n\n/usr/local/bin/docker-entrypoint.sh <span class=\"token operator\">&amp;</span>\n\n<span class=\"token function\">sleep</span> <span class=\"token number\">25</span>\n\npython3.8 manage.py search_index -f --rebuild\n\n<span class=\"token function\">sleep</span> <span class=\"token number\">5</span>\n\npython3.8 manage.py runserver <span class=\"token number\">0</span>:8000</code></pre></div>\n<p>처음에는 DB, 엘라스틱 서치, 백엔드(장고)로 나누어 총 3개의 컨테이너를 컴포즈 파일에 정의했었다. 하지만 동일한 네트워크에 (컴포즈에 묶는 컨테이너 파일들을 기본적으로 동일한 네트워크에 묶이게 된다.) 컨테이너가 있고 서로 통신이 되는 것을 확인해봐도 엘라스틱 서치가 작동을 하지 않았다. 나중에야 알게 된 사실이지만 컴포즈 파일을 실행(up) 한 뒤 <code class=\"language-text\">exec service명칭</code> 명령하면 되는 것 같았지만, 나는 <code class=\"language-text\">docker-compose up</code> 명령어를 쳤을 때 내부적으로 설정해 줘야하는 빌드도 자동화하고 싶어 이렇게 설계하게 되었다. 아래에 있는 컴포즈 파일은 MariaDB 공식 이미지를 사용해 환경변수를 추가하고 DB가 실행되었을 때 아래 <code class=\"language-text\">backend</code> 서비스가 실행하는 형식으로 구성했다.</p>\n<p>[docker-compose.yml]</p>\n<div class=\"gatsby-highlight\" data-language=\"dockerfile\"><pre class=\"language-dockerfile\"><code class=\"language-dockerfile\">version<span class=\"token punctuation\">:</span> <span class=\"token string\">'3'</span>\nservices<span class=\"token punctuation\">:</span>\n  <span class=\"token comment\"># DB 컨테이너 이름 정의</span>\n  database<span class=\"token punctuation\">:</span>\n    <span class=\"token comment\"># db 서비스에서 사용할 도커 이미지</span>\n    image<span class=\"token punctuation\">:</span> <span class=\"token string\">'mariadb'</span>\n    environment<span class=\"token punctuation\">:</span>\n      <span class=\"token punctuation\">-</span> MYSQL_ROOT_PASSWORD=project\n      <span class=\"token punctuation\">-</span> MYSQL_DATABASE=project_db\n      <span class=\"token punctuation\">-</span> MYSQL_USER=project\n      <span class=\"token punctuation\">-</span> MYSQL_PASSWORD=project\n\n  <span class=\"token comment\"># 앱 컨테이너 이름 정의</span>\n  backend<span class=\"token punctuation\">:</span>\n    depends_on<span class=\"token punctuation\">:</span>\n      <span class=\"token punctuation\">-</span> database\n    <span class=\"token comment\"># Dockerfile이 있는 위치</span>\n    build<span class=\"token punctuation\">:</span> .\n    ports<span class=\"token punctuation\">:</span>\n      <span class=\"token punctuation\">-</span> <span class=\"token string\">'8000:8000'</span>\n    environment<span class=\"token punctuation\">:</span>\n      <span class=\"token punctuation\">-</span> DJANGO_DB_HOST=database\n      <span class=\"token punctuation\">-</span> DJANGO_DEBUG=True\n      <span class=\"token punctuation\">-</span> <span class=\"token string\">'ES_JAVA_OPTS=-Xms512m -Xmx512m'</span>\n      <span class=\"token punctuation\">-</span> discovery.type=single<span class=\"token punctuation\">-</span>node\n    command<span class=\"token punctuation\">:</span> ./server_start.sh</code></pre></div>\n<p>이렇게 모두 작성하고 <code class=\"language-text\">docker-compose.yml</code> 파일이 있는 곳에서 <code class=\"language-text\">docker-compose up</code> 명령어를 치면 정상적으로 도커로 만든 장고 프로젝트가 실행되는 것을 확인해 볼 수 있었다.</p>\n<h1 id=\"reference\" style=\"position:relative;\"><a href=\"#reference\" aria-label=\"reference permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Reference</h1>\n<p><a href=\"https://www.elastic.co/guide/en/elasticsearch/reference/current/docker.html#_set_vm_max_map_count_to_at_least_262144\">https://www.elastic.co/guide/en/elasticsearch/reference/current/docker.html#_set<em>vm</em>max<em>map</em>count<em>to</em>at<em>least</em>262144</a></p>\n<p><a href=\"https://www.elastic.co/guide/en/elasticsearch/reference/current/vm-max-map-count.html\">https://www.elastic.co/guide/en/elasticsearch/reference/current/vm-max-map-count.html</a></p>\n<p><a href=\"https://msyu1207.tistory.com/entry/Elasticsearch-%EC%84%A4%EC%B9%98-%EB%B0%8F-%EC%99%B8%EB%B6%80-%ED%97%88%EC%9A%A9\">https://msyu1207.tistory.com/entry/Elasticsearch-%EC%84%A4%EC%B9%98-%EB%B0%8F-%EC%99%B8%EB%B6%80-%ED%97%88%EC%9A%A9</a></p>\n<p><a href=\"https://okayjava.tistory.com/30\">https://okayjava.tistory.com/30</a></p>\n<p><a href=\"https://mentha2.tistory.com/177\">https://mentha2.tistory.com/177</a></p>\n<p><a href=\"https://medium.com/@ian.nam.kr/elasticsearch-%EC%84%A4%EC%B9%98-973fb438f2\">https://medium.com/@ian.nam.kr/elasticsearch-%EC%84%A4%EC%B9%98-973fb438f2</a></p>\n<p><a href=\"https://jhnyang.tistory.com/268\">https://jhnyang.tistory.com/268</a></p>\n<p><a href=\"https://www.youtube.com/watch?v=xFcJPwVPc1o&#x26;t=1449s\">https://www.youtube.com/watch?v=xFcJPwVPc1o&#x26;t=1449s</a></p>","frontmatter":{"title":"장고프로젝트 docker로 배포하기 with elasticsearch","date":"February 02, 2021","category":"🐳 docker"}}},"pageContext":{"slug":"/docker/장고프로젝트 docker로 배포하기 with elasticsearch/","previous":{"fields":{"slug":"/docker/Docker network/"},"frontmatter":{"title":"도커 네트워크","category":"🐳 docker","draft":false}},"next":{"fields":{"slug":"/solving-algo/[프로그래머스]/[programmers]삼각 달팽이/"},"frontmatter":{"title":"[programmers]삼각 달팽이","category":"💯 solving-algo","draft":false}}}},"staticQueryHashes":["3128451518","521680639"]}